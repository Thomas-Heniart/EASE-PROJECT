{"version":3,"sources":["../source/input controller.js"],"names":["Input_controller","get_input_element","parse","format","on_change","element","onCut","bind","onPaste","onChange","onKeyDown","format_input_text","event","setTimeout","input","selection","erase_selection","operation","preventDefault","text","value","slice","start","end","caret","edit_result","format_result","undefined"],"mappings":"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","file":"input controller.js","sourcesContent":["import edit   from './edit'\nimport parse  from './parse'\nimport format from './format'\n\nimport { getSelection, getOperation, getCaretPosition, setCaretPosition } from './dom'\n\nexport default class Input_controller\n{\n\tconstructor(get_input_element, parse, format, on_change)\n\t{\n\t\tif (typeof get_input_element !== 'function')\n\t\t{\n\t\t\tconst element = get_input_element\n\t\t\tget_input_element = () => element\n\t\t}\n\n\t\tthis.get_input_element = get_input_element\n\t\tthis.parse = parse\n\t\tthis.format = format\n\t\tthis.on_change = on_change\n\n\t\tthis.onCut = this.onCut.bind(this)\n\t\tthis.onPaste = this.onPaste.bind(this)\n\t\tthis.onChange = this.onChange.bind(this)\n\t\tthis.onKeyDown = this.onKeyDown.bind(this)\n\t\tthis.format_input_text = this.format_input_text.bind(this)\n\t}\n\n\t// Special handling for \"Cut\" event because\n\t// it wouldn't copy to clipboard otherwise.\n\tonCut(event)\n\t{\n\t\tsetTimeout(this.format_input_text, 0)\n\t}\n\n\tonPaste(event)\n\t{\n\t\tconst input = this.get_input_element()\n\n\t\tconst selection = getSelection(input)\n\n\t\t// If selection is made,\n\t\t// just erase the selected text\n\t\t// prior to pasting\n\t\tif (selection)\n\t\t{\n\t\t\tthis.erase_selection(input, selection)\n\t\t}\n\n\t\tthis.format_input_text()\n\t}\n\n\tonChange(event)\n\t{\n\t\tthis.format_input_text()\n\t}\n\n\t// Intercepts \"Delete\" and \"Backspace\" keys\n\t// (hitting \"Delete\" or \"Backspace\"\n\t//  at any caret position should always result in\n\t//  erasing a digit)\n\tonKeyDown(event)\n\t{\n\t\tconst operation = getOperation(event)\n\n\t\tswitch (operation)\n\t\t{\n\t\t\tcase 'Delete':\n\t\t\tcase 'Backspace':\n\t\t\t\t// Intercept this operation and perform it manually.\n\t\t\t\tevent.preventDefault()\n\n\t\t\t\tconst input = this.get_input_element()\n\n\t\t\t\tconst selection = getSelection(input)\n\n\t\t\t\t// If selection is made,\n\t\t\t\t// just erase the selected text,\n\t\t\t\t// and don't apply any more operations to it.\n\t\t\t\tif (selection)\n\t\t\t\t{\n\t\t\t\t\tthis.erase_selection(input, selection)\n\t\t\t\t\treturn this.format_input_text()\n\t\t\t\t}\n\n\t\t\t\t// Else, perform the (character erasing) operation manually\n\t\t\t\treturn this.format_input_text(operation)\n\t\t}\n\t}\n\n\t// Erases the selected text inside an `<input/>`\n\terase_selection(input, selection)\n\t{\n\t\tlet text = input.value\n\t\ttext = text.slice(0, selection.start) + text.slice(selection.end)\n\n\t\tinput.value = text\n\t\tsetCaretPosition(input, selection.start)\n\n\t\treturn this.format_input_text()\n\t}\n\n\t// Formats <input/> textual value as a phone number\n\tformat_input_text(operation)\n\t{\n\t\t// <input/> DOM element\n\t\tconst input = this.get_input_element()\n\n\t\tlet { value, caret } = parse(input.value, getCaretPosition(input), this.parse)\n\n\t\t// Apply the pending operation to the <input/> textual value (if any)\n\t\tif (operation)\n\t\t{\n\t\t\tconst edit_result = edit(value, caret, operation)\n\n\t\t\tvalue = edit_result.value\n\t\t\tcaret = edit_result.caret\n\t\t}\n\n\t\t// Format the <input/> textual value as a phone number\n\t\t// (and reposition the caret accordingly)\n\n\t\tconst format_result = format(value, caret, this.format)\n\n\t\tconst text = format_result.text\n\t\tcaret      = format_result.caret\n\n\t\t// Set <input/> textual value manually to also set caret position\n\t\t// and prevent React from resetting the caret position later\n\t\t// inside subsequent `render()`.\n\t\tinput.value = text\n\t\t// Set caret position (with the neccessary adjustments)\n\t\tsetCaretPosition(input, caret)\n\n\t\t// <input/> textual value may have been changed,\n\t\t// so `value` may have been changed too.\n\t\tthis.on_change(value)\n\t}\n\n\t// Parses `<input/>` text\n\tgetParsedValue()\n\t{\n\t\t// <input/> DOM element\n\t\tconst input = this.get_input_element()\n\n\t\treturn parse(input.value, undefined, this.parse)\n\t}\n}"]}