'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _edit = require('./edit');

var _edit2 = _interopRequireDefault(_edit);

var _parse2 = require('./parse');

var _parse3 = _interopRequireDefault(_parse2);

var _format = require('./format');

var _format2 = _interopRequireDefault(_format);

var _dom = require('./dom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Input_controller = function () {
	function Input_controller(get_input_element, parse, format, on_change) {
		(0, _classCallCheck3.default)(this, Input_controller);

		if (typeof get_input_element !== 'function') {
			(function () {
				var element = get_input_element;
				get_input_element = function get_input_element() {
					return element;
				};
			})();
		}

		this.get_input_element = get_input_element;
		this.parse = parse;
		this.format = format;
		this.on_change = on_change;

		this.onCut = this.onCut.bind(this);
		this.onPaste = this.onPaste.bind(this);
		this.onChange = this.onChange.bind(this);
		this.onKeyDown = this.onKeyDown.bind(this);
		this.format_input_text = this.format_input_text.bind(this);
	}

	// Special handling for "Cut" event because
	// it wouldn't copy to clipboard otherwise.


	(0, _createClass3.default)(Input_controller, [{
		key: 'onCut',
		value: function onCut(event) {
			setTimeout(this.format_input_text, 0);
		}
	}, {
		key: 'onPaste',
		value: function onPaste(event) {
			var input = this.get_input_element();

			var selection = (0, _dom.getSelection)(input);

			// If selection is made,
			// just erase the selected text
			// prior to pasting
			if (selection) {
				this.erase_selection(input, selection);
			}

			this.format_input_text();
		}
	}, {
		key: 'onChange',
		value: function onChange(event) {
			this.format_input_text();
		}

		// Intercepts "Delete" and "Backspace" keys
		// (hitting "Delete" or "Backspace"
		//  at any caret position should always result in
		//  erasing a digit)

	}, {
		key: 'onKeyDown',
		value: function onKeyDown(event) {
			var operation = (0, _dom.getOperation)(event);

			switch (operation) {
				case 'Delete':
				case 'Backspace':
					// Intercept this operation and perform it manually.
					event.preventDefault();

					var input = this.get_input_element();

					var selection = (0, _dom.getSelection)(input);

					// If selection is made,
					// just erase the selected text,
					// and don't apply any more operations to it.
					if (selection) {
						this.erase_selection(input, selection);
						return this.format_input_text();
					}

					// Else, perform the (character erasing) operation manually
					return this.format_input_text(operation);
			}
		}

		// Erases the selected text inside an `<input/>`

	}, {
		key: 'erase_selection',
		value: function erase_selection(input, selection) {
			var text = input.value;
			text = text.slice(0, selection.start) + text.slice(selection.end);

			input.value = text;
			(0, _dom.setCaretPosition)(input, selection.start);

			return this.format_input_text();
		}

		// Formats <input/> textual value as a phone number

	}, {
		key: 'format_input_text',
		value: function format_input_text(operation) {
			// <input/> DOM element
			var input = this.get_input_element();

			var _parse = (0, _parse3.default)(input.value, (0, _dom.getCaretPosition)(input), this.parse),
			    value = _parse.value,
			    caret = _parse.caret;

			// Apply the pending operation to the <input/> textual value (if any)


			if (operation) {
				var edit_result = (0, _edit2.default)(value, caret, operation);

				value = edit_result.value;
				caret = edit_result.caret;
			}

			// Format the <input/> textual value as a phone number
			// (and reposition the caret accordingly)

			var format_result = (0, _format2.default)(value, caret, this.format);

			var text = format_result.text;
			caret = format_result.caret;

			// Set <input/> textual value manually to also set caret position
			// and prevent React from resetting the caret position later
			// inside subsequent `render()`.
			input.value = text;
			// Set caret position (with the neccessary adjustments)
			(0, _dom.setCaretPosition)(input, caret);

			// <input/> textual value may have been changed,
			// so `value` may have been changed too.
			this.on_change(value);
		}

		// Parses `<input/>` text

	}, {
		key: 'getParsedValue',
		value: function getParsedValue() {
			// <input/> DOM element
			var input = this.get_input_element();

			return (0, _parse3.default)(input.value, undefined, this.parse);
		}
	}]);
	return Input_controller;
}();

exports.default = Input_controller;
//# sourceMappingURL=input controller.js.map